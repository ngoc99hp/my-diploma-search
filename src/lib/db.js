// lib/db.js - Updated for Schema v2.0
import { Pool } from 'pg';

let pool;

function getSSLConfig() {
  const databaseUrl = process.env.DATABASE_URL;
  
  if (!databaseUrl) {
    return false;
  }

  if (databaseUrl.includes('sslmode=disable')) {
    return false;
  }

  if (databaseUrl.includes('sslmode=require')) {
    return {
      rejectUnauthorized: false
    };
  }

  if (process.env.NODE_ENV === 'production') {
    return {
      rejectUnauthorized: false,
      checkServerIdentity: () => undefined
    };
  }

  return false;
}

function getPool() {
  if (!pool) {
    const sslConfig = getSSLConfig();
    
    // ‚úÖ OPTIMIZED POOL CONFIGURATION
    const poolConfig = {
      connectionString: process.env.DATABASE_URL,
      
      // ‚úÖ TƒÉng pool size cho production
      min: process.env.NODE_ENV === 'production' 
        ? parseInt(process.env.DB_POOL_MIN || '5')
        : parseInt(process.env.DB_POOL_MIN || '2'),
      
      max: process.env.NODE_ENV === 'production'
        ? parseInt(process.env.DB_POOL_MAX || '20')
        : parseInt(process.env.DB_POOL_MAX || '10'),
      
      // ‚úÖ Connection timeout - nhanh h∆°n
      connectionTimeoutMillis: 3000, // 3s (t·ª´ 5s)
      
      // ‚úÖ Idle timeout - gi·ªØ connection l√¢u h∆°n
      idleTimeoutMillis: 60000, // 60s (t·ª´ 30s)
      
      // ‚úÖ Statement timeout - tr√°nh query ch·∫°y m√£i
      statement_timeout: 10000, // 10s max per query
      
      // ‚úÖ Query timeout
      query_timeout: 10000,
      
      // ‚úÖ Application name for monitoring
      application_name: 'diploma-search-system',
      
      ssl: sslConfig
    };

    pool = new Pool(poolConfig);

    // ‚úÖ Enhanced error handling
    pool.on('error', (err) => {
      console.error('‚ùå Unexpected pool error:', err);
    });

    pool.on('connect', (client) => {
      console.log('‚úÖ New client connected to pool');
      
      // Set session parameters for better performance
      client.query('SET timezone = \'Asia/Ho_Chi_Minh\'');
      client.query('SET statement_timeout = 10000'); // 10s
    });

    pool.on('acquire', (client) => {
      console.log('üìå Client acquired from pool');
    });

    pool.on('remove', (client) => {
      console.log('üóëÔ∏è Client removed from pool');
    });
  }

  return pool;
}

export async function query(text, params) {
  const start = Date.now();
  const client = getPool();
  
  try {
    const result = await client.query(text, params);
    const duration = Date.now() - start;
    
    if (process.env.NODE_ENV === 'development') {
      console.log('Executed query', {
        text: text.substring(0, 100),
        duration: `${duration}ms`,
        rows: result.rowCount
      });
    }
    
    return result;
  } catch (error) {
    if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {
      console.error('‚ùå Database connection failed:', error.message);
      const dbError = new Error('Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i sau.');
      dbError.code = 'DB_CONNECTION_ERROR';
      throw dbError;
    }

    if (error.message?.includes('SSL') || error.message?.includes('ssl')) {
      console.error('‚ùå SSL connection error:', error.message);
      const sslError = new Error('L·ªói k·∫øt n·ªëi database (SSL). Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh.');
      sslError.code = 'DB_SSL_ERROR';
      throw sslError;
    }

    if (error.code === '23505') {
      const duplicateError = new Error('D·ªØ li·ªáu ƒë√£ t·ªìn t·∫°i trong h·ªá th·ªëng');
      duplicateError.code = 'DUPLICATE_ERROR';
      throw duplicateError;
    }

    if (error.code === '23503') {
      const fkError = new Error('Kh√¥ng th·ªÉ th·ª±c hi·ªán thao t√°c do r√†ng bu·ªôc d·ªØ li·ªáu');
      fkError.code = 'FK_VIOLATION';
      throw fkError;
    }

    console.error('Database query error:', {
      text,
      error: error.message,
      code: error.code,
      stack: error.stack
    });
    
    throw error;
  }
}

export async function getClient() {
  const client = await getPool().connect();
  
  const release = client.release;
  const timeout = setTimeout(() => {
    console.error('A client has been checked out for more than 5 seconds!');
  }, 5000);
  
  client.release = () => {
    clearTimeout(timeout);
    return release.apply(client);
  };
  
  return client;
}

export async function transaction(callback) {
  const client = await getClient();
  
  try {
    await client.query('BEGIN');
    const result = await callback(client);
    await client.query('COMMIT');
    return result;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

export async function closePool() {
  if (pool) {
    await pool.end();
    pool = null;
    console.log('Database pool closed');
  }
}

export async function testConnection() {
  try {
    const result = await query('SELECT NOW() as current_time, current_database() as db_name, version() as pg_version');
    console.log('‚úÖ Database connection test successful:', {
      time: result.rows[0].current_time,
      database: result.rows[0].db_name,
      version: result.rows[0].pg_version.split(',')[0]
    });
    return true;
  } catch (error) {
    console.error('‚ùå Database connection test failed:', error.message);
    return false;
  }
}

/**
 * T√¨m ki·∫øm vƒÉn b·∫±ng theo s·ªë hi·ªáu (Schema v2)
 */
export async function searchDiplomaByNumber(soHieuVBCC) {
  try {
    const result = await query(
      `SELECT 
        ma_dinh_danh_vbcc,
        so_hieu_vbcc,
        ho_va_ten,
        ngay_sinh,
        noi_sinh,
        gioi_tinh,
        ma_nguoi_hoc,
        nganh_dao_tao,
        chuyen_nganh_dao_tao,
        xep_loai,
        nam_tot_nghiep,
        hinh_thuc_dao_tao,
        thoi_gian_dao_tao,
        don_vi_cap_bang,
        ngay_cap_vbcc,
        dia_danh_cap_vbcc,
        trinh_do_theo_khung_quoc_gia,
        bac_trinh_do_theo_khung_quoc_gia
      FROM diplomas
      WHERE so_hieu_vbcc = $1
      AND is_active = TRUE
      LIMIT 1`,
      [soHieuVBCC]
    );

    return result.rows[0] || null;
  } catch (error) {
    if (error.code === 'DB_CONNECTION_ERROR' || error.code === 'DB_SSL_ERROR') {
      throw error;
    }
    console.error('Search diploma error:', error);
    throw new Error('L·ªói khi tra c·ª©u vƒÉn b·∫±ng');
  }
}

/**
 * T√¨m ki·∫øm vƒÉn b·∫±ng theo M√£ SV + H·ªç t√™n/Ng√†y sinh
 * OPTIMIZED VERSION v·ªõi prepared statement hints
 */
export async function searchDiplomaCombo(maNguoiHoc, hoVaTen = null, ngaySinh = null) {
  try {
    if (!hoVaTen && !ngaySinh) {
      throw new Error('Vui l√≤ng nh·∫≠p th√™m H·ªç t√™n ho·∫∑c Ng√†y sinh');
    }

    // ‚úÖ OPTIMIZATION: Ch·ªçn query t·ªëi ∆∞u d·ª±a tr√™n input
    let queryText;
    let params;

    if (hoVaTen && ngaySinh) {
      // C·∫£ h·ªç t√™n V√Ä ng√†y sinh - query ch√≠nh x√°c nh·∫•t
      queryText = `
        SELECT 
          ma_dinh_danh_vbcc, so_hieu_vbcc, ho_va_ten, ngay_sinh, 
          noi_sinh, gioi_tinh, ma_nguoi_hoc, nganh_dao_tao, 
          chuyen_nganh_dao_tao, xep_loai, nam_tot_nghiep, 
          hinh_thuc_dao_tao, thoi_gian_dao_tao, don_vi_cap_bang, 
          ngay_cap_vbcc, dia_danh_cap_vbcc, 
          trinh_do_theo_khung_quoc_gia, bac_trinh_do_theo_khung_quoc_gia
        FROM diplomas
        WHERE ma_nguoi_hoc = $1
          AND UPPER(ho_va_ten) = UPPER($2)
          AND ngay_sinh = $3
          AND is_active = TRUE
        LIMIT 1
      `;
      params = [maNguoiHoc, hoVaTen, ngaySinh];

    } else if (hoVaTen) {
      // Ch·ªâ c√≥ h·ªç t√™n
      queryText = `
        SELECT 
          ma_dinh_danh_vbcc, so_hieu_vbcc, ho_va_ten, ngay_sinh, 
          noi_sinh, gioi_tinh, ma_nguoi_hoc, nganh_dao_tao, 
          chuyen_nganh_dao_tao, xep_loai, nam_tot_nghiep, 
          hinh_thuc_dao_tao, thoi_gian_dao_tao, don_vi_cap_bang, 
          ngay_cap_vbcc, dia_danh_cap_vbcc, 
          trinh_do_theo_khung_quoc_gia, bac_trinh_do_theo_khung_quoc_gia
        FROM diplomas
        WHERE ma_nguoi_hoc = $1
          AND UPPER(ho_va_ten) = UPPER($2)
          AND is_active = TRUE
        LIMIT 1
      `;
      params = [maNguoiHoc, hoVaTen];

    } else {
      // Ch·ªâ c√≥ ng√†y sinh
      queryText = `
        SELECT 
          ma_dinh_danh_vbcc, so_hieu_vbcc, ho_va_ten, ngay_sinh, 
          noi_sinh, gioi_tinh, ma_nguoi_hoc, nganh_dao_tao, 
          chuyen_nganh_dao_tao, xep_loai, nam_tot_nghiep, 
          hinh_thuc_dao_tao, thoi_gian_dao_tao, don_vi_cap_bang, 
          ngay_cap_vbcc, dia_danh_cap_vbcc, 
          trinh_do_theo_khung_quoc_gia, bac_trinh_do_theo_khung_quoc_gia
        FROM diplomas
        WHERE ma_nguoi_hoc = $1
          AND ngay_sinh = $2
          AND is_active = TRUE
        LIMIT 1
      `;
      params = [maNguoiHoc, ngaySinh];
    }

    const result = await query(queryText, params);
    return result.rows[0] || null;

  } catch (error) {
    if (error.code === 'DB_CONNECTION_ERROR' || error.code === 'DB_SSL_ERROR') {
      throw error;
    }
    console.error('Search diploma combo error:', error);
    throw new Error('L·ªói khi tra c·ª©u vƒÉn b·∫±ng');
  }
}

/**
 * Log tra c·ª©u v√†o database
 * FIXED: Th√™m diploma_number ƒë·ªÉ hi·ªÉn th·ªã trong admin panel
 */
export async function logSearch(
  diplomaNumber,      // S·ªë hi·ªáu vƒÉn b·∫±ng (plaintext)
  ipAddress, 
  userAgent, 
  found, 
  responseTimeMs, 
  captchaScore = null, 
  captchaStatus = null, 
  errorMessage = null
) {
  if (process.env.ENABLE_SEARCH_LOGGING !== 'true') {
    return;
  }

  try {
    // Hash search value ƒë·ªÉ b·∫£o m·∫≠t (v·∫´n gi·ªØ cho audit)
    const crypto = await import('crypto');
    const searchHash = crypto.createHash('sha256')
      .update(diplomaNumber || 'unknown')
      .digest('hex');

    // ‚úÖ INSERT v·ªõi C·∫¢ diploma_number V√Ä search_value_hash
    await query(
      `INSERT INTO search_logs 
        (ip_address, user_agent, search_type, diploma_number, search_value_hash, 
         found, response_time_ms, captcha_score, captcha_status, error_message)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
      [
        ipAddress, 
        userAgent, 
        'so_hieu',
        diplomaNumber,    // ‚úÖ TH√äM: L∆∞u plaintext ƒë·ªÉ hi·ªÉn th·ªã
        searchHash,       // Hash ƒë·ªÉ b·∫£o m·∫≠t
        found, 
        responseTimeMs, 
        captchaScore, 
        captchaStatus, 
        errorMessage
      ]
    );
  } catch (error) {
    console.error('Failed to log search:', error);
  }
}

/**
 * Ki·ªÉm tra rate limit
 */
export async function checkRateLimit(ipAddress) {
  try {
    const windowMs = parseInt(process.env.RATE_LIMIT_WINDOW_MS || '3600000');
    const maxRequests = parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '30');
    const windowStart = new Date(Date.now() - windowMs);
    
    const result = await query(
      `SELECT COUNT(*) as request_count
      FROM search_logs
      WHERE ip_address = $1
      AND search_time >= $2`,
      [ipAddress, windowStart]
    );

    const requestCount = parseInt(result.rows[0].request_count);
    return {
      allowed: requestCount < maxRequests,
      remaining: Math.max(0, maxRequests - requestCount),
      limit: maxRequests,
      resetAt: new Date(Date.now() + windowMs)
    };
  } catch (error) {
    console.error('Rate limit check error:', error);
    return {
      allowed: true,
      remaining: 100,
      limit: 100,
      resetAt: new Date(Date.now() + 3600000)
    };
  }
}

/**
 * Log h√†nh ƒë·ªông admin
 */
export async function logAdminAction(adminId, action, tableName, recordId, oldData, newData, description, ipAddress) {
  if (process.env.ENABLE_ADMIN_LOGGING !== 'true') {
    return;
  }

  try {
    await query(
      `INSERT INTO admin_logs 
        (admin_id, action, table_name, record_id, old_data, new_data, description, ip_address)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        adminId,
        action,
        tableName,
        recordId,
        oldData ? JSON.stringify(oldData) : null,
        newData ? JSON.stringify(newData) : null,
        description,
        ipAddress
      ]
    );
  } catch (error) {
    console.error('Failed to log admin action:', error);
  }
}

/**
 * Get connection pool statistics
 * ‚úÖ TH√äM FUNCTION M·ªöI N√ÄY
 */
export function getPoolStats() {
  if (!pool) {
    return {
      total: 0,
      idle: 0,
      waiting: 0,
      status: 'not_initialized'
    };
  }

  return {
    total: pool.totalCount,
    idle: pool.idleCount,
    waiting: pool.waitingCount,
    status: 'active'
  };
}

export default {
  query,
  getClient,
  transaction,
  closePool,
  testConnection,
  searchDiplomaByNumber,
  searchDiplomaCombo,
  logSearch,
  checkRateLimit,
  logAdminAction,
  getPoolStats
};

